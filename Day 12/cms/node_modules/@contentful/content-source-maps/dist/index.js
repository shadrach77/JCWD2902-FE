var R = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, x = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, k = new Array(4).fill(String.fromCodePoint(x[0])).join(""), M = "\0";
function _(e) {
  let t = JSON.stringify(e);
  return `${k}${Array.from(t).map((r) => {
    let o = r.charCodeAt(0);
    if (o > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${t} on character ${r} (${o})`);
    return Array.from(o.toString(4).padStart(4, "0")).map((n) => String.fromCodePoint(x[n])).join("");
  }).join("")}`;
}
function B(e) {
  return !Number.isNaN(Number(e)) || /[a-z]/i.test(e) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(e) ? !1 : !!Date.parse(e);
}
function D(e) {
  try {
    new URL(e, e.startsWith("/") ? "https://acme.com" : void 0);
  } catch (t) {
    return !1;
  }
  return !0;
}
function Q(e, t, r = "auto") {
  return r === !0 || r === "auto" && (B(e) || D(e)) ? e : `${e}${_(t)}`;
}
var z = Object.fromEntries(Object.entries(x).map((e) => e.reverse())), J = Object.fromEntries(Object.entries(R).map((e) => e.reverse())), G = `${Object.values(R).map((e) => `\\u{${e.toString(16)}}`).join("")}`, N = new RegExp(`[${G}]{4,}`, "gu");
function Z(e) {
  let t = e.match(N);
  if (t) return H(t[0], !0)[0];
}
function H(e, t = !1) {
  let r = Array.from(e);
  if (r.length % 2 === 0) {
    if (r.length % 4 || !e.startsWith(k)) return K(r, t);
  } else throw new Error("Encoded data has invalid length");
  let o = [];
  for (let n = r.length * 0.25; n--; ) {
    let s = r.slice(n * 4, n * 4 + 4).map((i) => z[i.codePointAt(0)]).join("");
    o.unshift(String.fromCharCode(parseInt(s, 4)));
  }
  if (t) {
    o.shift();
    let n = o.indexOf(M);
    return n === -1 && (n = o.length), [JSON.parse(o.slice(0, n).join(""))];
  }
  return o.join("").split(M).filter(Boolean).map((n) => JSON.parse(n));
}
function K(e, t) {
  var r;
  let o = [];
  for (let c = e.length * 0.5; c--; ) {
    let a = `${J[e[c * 2].codePointAt(0)]}${J[e[c * 2 + 1].codePointAt(0)]}`;
    o.unshift(String.fromCharCode(parseInt(a, 16)));
  }
  let n = [], s = [o.join("")], i = 10;
  for (; s.length; ) {
    let c = s.shift();
    try {
      if (n.push(JSON.parse(c)), t) return n;
    } catch (a) {
      if (!i--) throw a;
      let u = +((r = a.message.match(/\sposition\s(\d+)$/)) == null ? void 0 : r[1]);
      if (!u) throw a;
      s.unshift(c.substring(0, u), c.substring(u));
    }
  }
  return n;
}
function X(e) {
  var t;
  return { cleaned: e.replace(N, ""), encoded: ((t = e.match(N)) == null ? void 0 : t[0]) || "" };
}
function O(e, t) {
  return Q(e, t);
}
function oe(e) {
  return _(e);
}
function se(e) {
  return Z(e);
}
function ce(e) {
  return X(e);
}
var Y = Object.prototype.hasOwnProperty, q = Object.prototype.toString, ee = function(t, r, o) {
  if (q.call(r) !== "[object Function]")
    throw new TypeError("iterator must be a function");
  var n = t.length;
  if (n === +n)
    for (var s = 0; s < n; s++)
      r.call(o, t[s], s, t);
  else
    for (var i in t)
      Y.call(t, i) && r.call(o, t[i], i, t);
}, te = ee, y = f;
function f(e, t, r) {
  if (arguments.length === 3)
    return f.set(e, t, r);
  if (arguments.length === 2)
    return f.get(e, t);
  var o = f.bind(f, e);
  for (var n in f)
    f.hasOwnProperty(n) && (o[n] = f[n].bind(o, e));
  return o;
}
f.get = function(t, r) {
  for (var o = Array.isArray(r) ? r : f.parse(r), n = 0; n < o.length; ++n) {
    var s = o[n];
    if (!(typeof t == "object" && s in t))
      throw new Error("Invalid reference token: " + s);
    t = t[s];
  }
  return t;
};
f.set = function(t, r, o) {
  var n = Array.isArray(r) ? r : f.parse(r), s = n[0];
  if (n.length === 0)
    throw Error("Can not set the root object");
  for (var i = 0; i < n.length - 1; ++i) {
    var c = n[i];
    typeof c != "string" && typeof c != "number" && (c = String(c)), !(c === "__proto__" || c === "constructor" || c === "prototype") && (c === "-" && Array.isArray(t) && (c = t.length), s = n[i + 1], c in t || (s.match(/^(\d+|-)$/) ? t[c] = [] : t[c] = {}), t = t[c]);
  }
  return s === "-" && Array.isArray(t) && (s = t.length), t[s] = o, this;
};
f.remove = function(e, t) {
  var r = Array.isArray(t) ? t : f.parse(t), o = r[r.length - 1];
  if (o === void 0)
    throw new Error('Invalid JSON pointer for remove: "' + t + '"');
  var n = f.get(e, r.slice(0, -1));
  if (Array.isArray(n)) {
    var s = +o;
    if (o === "" && isNaN(s))
      throw new Error('Invalid array index: "' + o + '"');
    Array.prototype.splice.call(n, s, 1);
  } else
    delete n[o];
};
f.dict = function(t, r) {
  var o = {};
  return f.walk(t, function(n, s) {
    o[s] = n;
  }, r), o;
};
f.walk = function(t, r, o) {
  var n = [];
  o = o || function(s) {
    var i = Object.prototype.toString.call(s);
    return i === "[object Object]" || i === "[object Array]";
  }, function s(i) {
    te(i, function(c, a) {
      n.push(String(a)), o(c) ? s(c) : r(c, f.compile(n)), n.pop();
    });
  }(t);
};
f.has = function(t, r) {
  try {
    f.get(t, r);
  } catch (o) {
    return !1;
  }
  return !0;
};
f.escape = function(t) {
  return t.toString().replace(/~/g, "~0").replace(/\//g, "~1");
};
f.unescape = function(t) {
  return t.replace(/~1/g, "/").replace(/~0/g, "~");
};
f.parse = function(t) {
  if (t === "")
    return [];
  if (t.charAt(0) !== "/")
    throw new Error("Invalid JSON pointer: " + t);
  return t.substring(1).split(/\//).map(f.unescape);
};
f.compile = function(t) {
  return t.length === 0 ? "" : "/" + t.map(f.escape).join("/");
};
const ne = ({
  pointer: e,
  mappings: t,
  data: r,
  hiddenStrings: o
}) => {
  const n = t[e];
  delete t[e];
  const s = F(r, e);
  for (const i of s) {
    t[i] = n;
    const c = y.get(r, i), a = O(c, o);
    y.set(r, i, a);
  }
}, F = (e, t = "") => {
  const r = [], o = y.get(e, t);
  if (o.content)
    for (let n = 0; n < o.content.length; n++)
      o.content[n].nodeType === "text" ? r.push(`${t}/content/${n}/value`) : r.push(...F(e, `${t}/content/${n}`));
  return r;
}, I = ({
  entityId: e,
  entityType: t,
  space: r,
  environment: o,
  field: n,
  locale: s,
  editorInterface: i,
  fieldType: c,
  targetOrigin: a
}) => ({
  origin: "contentful.com",
  href: `${`${a || "https://app.contentful.com"}/spaces/${r}/environments/${o}`}/${t === "Entry" ? "entries" : "assets"}/${e}/?focusedField=${n}&focusedLocale=${s}`,
  contentful: {
    space: r,
    environment: o,
    field: n,
    locale: s,
    entity: e,
    entityType: t,
    editorInterface: i,
    fieldType: c
  }
}), V = (e) => ["builtin", "sidebar-builtin", "editor-builtin"].includes(e), W = (e) => re.includes(e);
function U(e) {
  if (typeof structuredClone == "function")
    return structuredClone(e);
  try {
    return JSON.parse(JSON.stringify(e));
  } catch (t) {
    return console.warn("Failed to clone data:", e, t), e;
  }
}
const re = [
  "singleLine",
  "tagEditor",
  "listInput",
  "checkbox",
  "richTextEditor",
  "multipleLine",
  "markdown"
];
function C(e, t, r, o, n, s, i) {
  const c = i ? t[i] : t;
  switch (e) {
    case "Symbol": {
      const a = O(c, r);
      y.set(o, n, a);
      break;
    }
    case "RichText": {
      ne({
        pointer: "",
        mappings: s,
        data: c,
        hiddenStrings: r
      });
      break;
    }
    case "Array": {
      const a = c.map((u) => typeof u == "string" ? O(u, r) : u);
      y.set(o, n, a);
      break;
    }
  }
}
const ie = (e, t) => {
  if (!e || !e.extensions || !e.extensions.contentSourceMaps)
    return console.error(
      "GraphQL response does not contain Content Source Maps information.",
      e
    ), e;
  const r = U(
    e
  ), {
    spaces: o,
    environments: n,
    editorInterfaces: s,
    fields: i,
    locales: c,
    entries: a,
    assets: u,
    mappings: m,
    fieldTypes: g
  } = r.extensions.contentSourceMaps, p = r;
  for (const d in m) {
    const { source: l } = m[d], h = "entry" in l ? a[l.entry] : u[l.asset], b = "entry" in l ? "Entry" : "Asset";
    if (!h)
      return r;
    const v = o[h.space], w = n[h.environment], A = h.id, S = i[l.field], E = c[l.locale], T = s[l.editorInterface], P = g[l.fieldType];
    if (!(V(T.widgetNamespace) && !W(T.widgetId)))
      if (y.has(p, d)) {
        const L = y.get(p, d);
        if (L !== null) {
          const j = I({
            entityId: A,
            entityType: b,
            space: v,
            environment: w,
            field: S,
            locale: E,
            editorInterface: T,
            fieldType: P,
            targetOrigin: t
          });
          C(P, L, j, p, d, m);
        }
      } else
        console.error(`Pointer ${d} not found in GraphQL data or href could not be generated.`);
  }
  return r;
}, $ = (e, t, r, o) => {
  if (!e.fields)
    return;
  const { contentSourceMaps: n } = e.sys;
  if (!n) {
    console.error("Content source maps data is missing");
    return;
  }
  const { mappings: s } = n;
  for (const i in s) {
    const { source: c } = s[i], a = e.sys.space.sys.id, u = e.sys.environment.sys.id, m = e.sys.id, g = e.sys.type, p = t[c.fieldType], d = r[c.editorInterface];
    if (V(d.widgetNamespace) && !W(d.widgetId))
      continue;
    const l = i.startsWith("/") ? i : `/${i}`;
    if (y.has(e, l)) {
      const h = y.get(e, l);
      if (h === null)
        return;
      const v = l.split("/").pop();
      if (!v) {
        console.error("Field name could not be extracted from the pointer", l);
        return;
      }
      const w = e.sys.locale;
      if (w) {
        const A = I({
          entityId: m,
          entityType: g,
          space: a,
          environment: u,
          field: v,
          locale: w,
          editorInterface: d,
          fieldType: p,
          targetOrigin: o
        });
        C(p, h, A, e, l, s);
      } else
        Object.keys(h).forEach((S) => {
          const E = I({
            entityId: m,
            entityType: g,
            space: a,
            environment: u,
            field: v,
            locale: S,
            editorInterface: d,
            fieldType: p,
            targetOrigin: o
          });
          C(
            p,
            h,
            E,
            e,
            `${l}/${S}`,
            s,
            S
          );
        });
    } else
      console.error("Pointer not found in the target", i, e);
  }
}, ae = (e, t) => {
  var o;
  const r = U(
    e
  );
  if (r.sys && "items" in r) {
    const n = r;
    if (!((o = n.sys) != null && o.contentSourceMapsLookup))
      return console.error("Content source maps lookup data is missing"), n;
    const {
      contentSourceMapsLookup: { fieldTypes: s, editorInterfaces: i }
    } = n.sys, { items: c, includes: a } = n;
    c.forEach((u) => $(u, s, i, t)), a && a.Entry && a.Entry.forEach(
      (u) => $(u, s, i, t)
    ), a && a.Asset && a.Asset.forEach(
      (u) => $(u, s, i, t)
    );
  } else {
    const n = r;
    if (!n.sys.contentSourceMapsLookup)
      return console.error("Content source maps lookup data is missing"), n;
    $(
      n,
      n.sys.contentSourceMapsLookup.fieldTypes,
      n.sys.contentSourceMapsLookup.editorInterfaces,
      t
    );
  }
  return r;
};
export {
  re as SUPPORTED_WIDGETS,
  U as clone,
  O as combine,
  I as createSourceMapMetadata,
  se as decode,
  oe as encode,
  ae as encodeCPAResponse,
  C as encodeField,
  ie as encodeGraphQLResponse,
  ne as encodeRichTextValue,
  V as isBuiltinNamespace,
  W as isSupportedWidget,
  ce as splitEncoding
};
//# sourceMappingURL=index.js.map
